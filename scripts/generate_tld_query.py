import requests
import json
import sys
import time
from collections import Counter

def generate_tld_query(tld_count=50):
    try:
        # Common legitimate TLDs to exclude
        blacklisted_tlds = {
            'com', 'net', 'org', 'nl'
        }
        
        url = "https://isc.sans.edu/api/recentdomains?json"
        print(f"[INFO] Making request to: {url}")
        
        print("[INFO] Waiting 15 seconds before making request...")
        time.sleep(15)
        
        max_retries = 3
        retry_count = 0
        
        headers = {
            'User-Agent': 'StormInt',
            'Accept': 'application/json',
            'Accept-Language': 'en-US,en;q=0.9'
        }
        
        while retry_count < max_retries:
            start_time = time.time()
            response = requests.get(url, headers=headers)
            elapsed_time = time.time() - start_time
            
            print(f"[DEBUG] Status code: {response.status_code}")
            print(f"[DEBUG] Headers: {dict(response.headers)}")
            print(f"[DEBUG] Request duration: {elapsed_time:.2f} seconds")
            
            try:
                if elapsed_time < 10:
                    wait_time = 10 - elapsed_time
                    print(f"[INFO] Waiting extra {wait_time:.2f} seconds to avoid rate limiting...")
                    time.sleep(wait_time)
                
                data = response.json()
                if data:
                    print("[INFO] Successfully parsed JSON response.")
                    break
                else:
                    print("[WARN] Empty JSON response.")
            except json.JSONDecodeError:
                print(f"[ERROR] Failed to parse JSON (attempt {retry_count + 1}/{max_retries})")
                print(f"[DEBUG] Response preview: {response.text[:200]}...")
                print("[INFO] Retrying after 20 seconds...")
                time.sleep(20)
                retry_count += 1
                continue
        
        if retry_count == max_retries:
            print("[FATAL] Max retries reached. Exiting.")
            return
            
        # Extract and count TLDs, excluding blacklisted ones
        tlds = [
            domain["domainname"].rsplit(".", 1)[-1]
            for domain in data if domain.get("domainname") and "." in domain["domainname"]
            and domain["domainname"].rsplit(".", 1)[-1] not in blacklisted_tlds
        ]
        tld_counts = Counter(tlds)
        top_tlds = [tld for tld, _ in tld_counts.most_common(tld_count)]
        
        if not top_tlds:
            print("[ERROR] No valid TLDs extracted after blacklist filtering.")
            return

        print(f"[INFO] Top {len(top_tlds)} TLDs after blacklist filtering: {', '.join(top_tlds)}")
        
        # Build the URL TLD query
        url_tld_query = f"""// Query generated by StormInt TLD Generator
// Source: SANS Internet Storm Center / DShield API
// License: CC BY-NC-SA 4.0
// Note: Common legitimate TLDs (.com, .net, .org, etc.) are excluded

let top_tlds = dynamic([{', '.join(f'"{tld}"' for tld in top_tlds)}]);
EmailUrlInfo
| where EmailDirection == "Inbound"
| where Url has_any(top_tlds) or Url matches regex @"https?://[^/]+\\.({'|'.join(top_tlds)})[/?]"
| project Url, NetworkMessageId
| join kind=inner (
    EmailEvents
    | where EmailDirection == "Inbound"
    | project 
        TimeGenerated,
        Subject,
        SenderFromAddress,
        RecipientEmailAddress,
        NetworkMessageId
) on NetworkMessageId
| summarize 
    LinkCount = count(),
    FirstSeen = min(TimeGenerated),
    LastSeen = max(TimeGenerated)
    by Url, Subject, SenderFromAddress
| order by LinkCount desc
"""

        # Build the sender domain TLD query
        sender_tld_query = f"""// Query generated by StormInt TLD Generator
// Source: SANS Internet Storm Center / DShield API
// License: CC BY-NC-SA 4.0
// Note: Common legitimate TLDs (.com, .net, .org, etc.) are excluded

let top_tlds = dynamic([{', '.join(f'"{tld}"' for tld in top_tlds)}]);
EmailEvents
| where EmailDirection == "Inbound"
| where SenderFromDomain has_any(top_tlds) 
    or SenderFromAddress matches regex @".*@[^@]+\\.({'|'.join(top_tlds)})$"
| project 
    TimeGenerated,
    Subject,
    SenderFromAddress,
    SenderFromDomain,
    RecipientEmailAddress,
    NetworkMessageId
| summarize 
    EmailCount = count(),
    FirstSeen = min(TimeGenerated),
    LastSeen = max(TimeGenerated)
    by SenderFromDomain, Subject, SenderFromAddress
| order by EmailCount desc
"""

        # Save both queries
        with open("stormint_url_tld_query.kql", "w") as f:
            f.write(url_tld_query)
            print("[INFO] URL TLD query saved to stormint_url_tld_query.kql")
            
        with open("stormint_sender_tld_query.kql", "w") as f:
            f.write(sender_tld_query)
            print("[INFO] Sender TLD query saved to stormint_sender_tld_query.kql")
            
    except requests.exceptions.RequestException as e:
        print(f"[ERROR] Request failed: {e}")
    except Exception as e:
        print(f"[ERROR] Unexpected error: {e}")

if __name__ == "__main__":
    tld_count = int(sys.argv[1]) if len(sys.argv) > 1 else 50
    generate_tld_query(tld_count)
